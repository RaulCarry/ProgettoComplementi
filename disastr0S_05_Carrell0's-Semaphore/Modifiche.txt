Modifiche fatte al SUO codice dal 20/05/2025 a 28/05/2025 (ci ho lavorato ogni giorno ma git sulla mia VM mi si bugga e non riesco a fare il commit, quindi ho aspettato finche non risolvessi tutti i problemi per fare il push, Mi scusi prof)

disastr0s_exit.c:

-Aggiunti "disastrOS_schedule.h" e "disastrOS_timer.h" per usare l'API di Scheduler e timer

-Se il padre stava in wait veniva inserito direttamente in running, adesso fa una pausetta e viene inserito nella ready_list

-Uso di For al posto dello while per il rilascio dei timer pendenti 

-Tutta la logica di scelta del prossimo processo da far girare (riattivazione, contesto, gestione zombie) viene ora svolta internamente in internal_schedule()

-Aggiunto setcontext(&main_context) alla fine che se non restano processi, si torna al contesto principale.


distro0s_schedule.c:

-Introduzione della variabile old_running per tenere traccia di chi era il running

-Aggiunto un "early return" se non ci sono processi pronti

-Re-enqueque condizionale del processo uscente: adesso viene ricordato solo se Ã¨ ancora in stato di running

-Viene effetivamente fatto uno swap_context da old_running a running:
"if (old_running){
  if (swapcontext(&old_running->cpu_state, &running->cpu_state) < 0) {
    perror("swapcontext");
    exit(1);}"

al primo avvio fa solamente setcontext (old_running non je sta)


disastr0s.c: 
https://www.diffchecker.com/zoIR9JcU/

-la logica di context switching Ã¨ interamente gestita da internal_schedule()

-




